<html lang="en">
    <head>
        <title>Ammo.js softbody rope demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }

            a {

                color: #a06851;
            }

        </style>
    </head>
    <body>
		<div id="info">Ammo.js soft body rope demo<br>Press Q or A to move the arm.</div>
        <div id="container"><br /><br /><br /><br /><br />Loading...</div>

		<script src="../../builds/ammo.js"></script>

        <script src="../js/three/three.min.js"></script>
        <script src="../js/three/OrbitControls.js"></script>
        <script src="../js/three/ConvexGeometry.js"></script>
        <script src="../js/three/Detector.js"></script>
        <script src="../js/three/stats.min.js"></script>

        <script>

			// Detects webgl
            if ( ! Detector.webgl ) {
                Detector.addGetWebGLMessage();
                document.getElementById( 'container' ).innerHTML = "";
            }

            // - Global variables -

			// Graphics variables
            var container, stats;
            var camera, controls, scene, renderer;
            var textureLoader;
            var clock = new THREE.Clock();

            // Physics variables
            var gravityConstant = -9.8;
			var collisionConfiguration;
			var dispatcher;
			var broadphase;
			var solver;
			var physicsWorld;
			var rigidBodies = [];
			var margin = 0.05;
			var hinge;
			var ellipsoid;
			var transformAux1 = new Ammo.btTransform();

			var time = 0;
			var armMovement = 0;

			// - Main code -

            init();
            animate();


            // - Functions -

            function init() {

				initGraphics();

				initPhysics();

				createObjects();

				//initInput();

            }

            function initGraphics() {

				container = document.getElementById( 'container' );

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

                scene = new THREE.Scene();

				camera.position.x = -7;
				camera.position.y = 5;
                camera.position.z =  8;

                controls = new THREE.OrbitControls( camera );
                controls.target.y = 2;

                renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.shadowMap.enabled = true;

                textureLoader = new THREE.TextureLoader();

				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );

                var light = new THREE.DirectionalLight( 0xffffff, 1 );
                light.position.set( -10, 10, 5 );
				light.castShadow = true;
				var d = 10;
			    light.shadowCameraLeft = -d;
			    light.shadowCameraRight = d;
			    light.shadowCameraTop = d;
			    light.shadowCameraBottom = -d;

			    light.shadowCameraNear = 2;
			    light.shadowCameraFar = 50;

			    light.shadowMapWidth = 1024;
			    light.shadowMapHeight = 1024;

			    light.shadowDarkness = 0.65;
                scene.add( light );


                container.innerHTML = "";

                container.appendChild( renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild( stats.domElement );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

			function initPhysics() {

				// Physics configuration

				collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
				dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
				broadphase = new Ammo.btDbvtBroadphase();
				solver = new Ammo.btSequentialImpulseConstraintSolver();
				softBodySolver = new Ammo.btDefaultSoftBodySolver();
				physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
				physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
				physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );

            }

            function createObjects() {

				var pos = new THREE.Vector3();
				var quat = new THREE.Quaternion();

				// Ground
				pos.set( 0, - 0.5, 0 );
				quat.set( 0, 0, 0, 1 );
				var ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
				ground.castShadow = true;
				ground.receiveShadow = true;
				textureLoader.load( "../textures/grid.png", function( texture ) {
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set( 40, 40 );
					ground.material.map = texture;
					ground.material.needsUpdate = true;
				} );


				// Ball
				var ballMass = 1.2;
				var ballRadius = 0.6;

				var ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 20, 20 ), new THREE.MeshPhongMaterial( { color: 0x202020 } ) );
				ball.castShadow = true;
				ball.receiveShadow = true;
				var ballShape = new Ammo.btSphereShape( ballRadius );
				ballShape.setMargin( margin );
				pos.set( -3, 2, 0 );
				quat.set( 0, 0, 0, 1 );
				createRigidBody( ball, ballShape, ballMass, pos, quat );
				ball.userData.physicsBody.setFriction( 0.5 );

				// Wall
				var brickMass = 1;//0.5;
				var brickLength = 3;//1.2;
				var brickDepth = 3;//0.6;
				var brickHeight = brickLength * 0.5;
				var numBricksLength = 6;
				var numBricksHeight = 2;
				var z0 = - numBricksLength * brickLength * 0.5;
				pos.set( 0, brickHeight * 0.5, z0 );
				quat.set( 0, 0, 0, 1 );
				for ( var j = 0; j < numBricksHeight; j ++ ) {

					var oddRow = ( j % 2 ) == 1;

					pos.z = z0;

					if ( oddRow ) {
						pos.z -= 0.25 * brickLength;
					}

					var nRow = oddRow? numBricksLength + 1 : numBricksLength;
					for ( var i = 0; i < nRow; i ++ ) {

						var brickLengthCurrent = brickLength;
						var brickMassCurrent = brickMass;
						if ( oddRow && ( i == 0 || i == nRow - 1 ) ) {
							brickLengthCurrent *= 0.5;
							brickMassCurrent *= 0.5;
						}

						var brick = createParalellepiped( brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial() );
						brick.castShadow = true;
						brick.receiveShadow = true;

						if ( oddRow && ( i == 0 || i == nRow - 2 ) ) {
							pos.z += 0.75 * brickLength;
						}
						else {
							pos.z += brickLength;
						}

					}
					pos.y += brickHeight;
				}

                // Ellipsoid physic object
                var numVertices = 256;
                var softBodyHelpers = new Ammo.btSoftBodyHelpers();
                var position = new Ammo.btVector3( 0, 10, 0 );
                var radius = new Ammo.btVector3( 3, 1, 3 );
                var ellipsoidSoftBody = softBodyHelpers.CreateEllipsoid( physicsWorld.getWorldInfo(), position, radius, numVertices );
                var sbConfig = ellipsoidSoftBody.get_m_cfg();
                sbConfig.set_viterations( 10 );
                sbConfig.set_piterations( 10 );
                sbConfig.set_citerations( 4 );
                sbConfig.set_kDF(1);
                sbConfig.set_kDP(0.001);
                sbConfig.set_kPR(1500);

                ellipsoidSoftBody.get_m_materials().at(0).set_m_kLST(0.1);

                ellipsoidSoftBody.setTotalMass( 2, false )
                Ammo.castObject( ellipsoidSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( 0.05 );
                physicsWorld.addSoftBody( ellipsoidSoftBody, 1, -1 );
                ellipsoidSoftBody.setActivationState( 4 );

                // get ellipsoid points
                var points = [];
                var ar = [];
                var b = ellipsoidSoftBody.get_m_nodes();
                var j = numVertices, n, node, p, k, i;
                while(j--){
                    n = j*3;
                    node = b.at( j );
                    p = node.get_m_x();
                    ar[n] = p.x();
                    ar[n+1] = p.y();
                    ar[n+2] = p.z();
                    points.push( new THREE.Vector3( p.x(), p.y(), p.z() ) );
                }

                // prepa geometry
                var tempGeo = new THREE.ConvexGeometry( points );

                // The Ellipsoid

                var indices = new Uint16Array( tempGeo.faces.length * 3 );
                var vertices = new Float32Array( numVertices * 3 );
                var order = new Float32Array( numVertices );

                // compare vertices on tempgeo to point to get order
                i = numVertices;
                var v = tempGeo.vertices;
                while(i--){
                    j = numVertices;
                    while(j--){
                        n = j*3;
                        if( ar[n]==v[i].x && ar[n+1]==v[i].y && ar[n+2]==v[i].z ) order[j] = i;
                    }
                }

                i = numVertices;
                while(i--){
                    n = i*3;
                    k = order[i]*3;

                    vertices[k] = ar[n];
                    vertices[k+1] = ar[n+1];
                    vertices[k+2] = ar[n+2];
                }

                // get indices of faces
                var i = tempGeo.faces.length;
                while(i--){
                    n = i*3;
                    var face = tempGeo.faces[i];
                    indices[n] = face.a;
                    indices[n+1] = face.b;
                    indices[n+2] = face.c;
                }

                //console.log(gtt.vertices.length)
                var g = new THREE.BufferGeometry();
                g.setIndex( new THREE.BufferAttribute( indices, 1 ) );
                g.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                //g.addAttribute('color', new THREE.BufferAttribute( new Float32Array( numVertices * 3 ), 3 ));
                g.addAttribute('order', new THREE.BufferAttribute( order, 1 ));
                g.computeVertexNormals();


                tempGeo.dispose();

                // The Ellipsoid Mesh
                ellipsoid = new THREE.Mesh( g, new THREE.MeshPhongMaterial( { color: 0xFF88CC } ) );
                ellipsoid.castShadow = true;
                ellipsoid.receiveShadow = true;
                scene.add( ellipsoid );

                ellipsoid.userData.physicsBody = ellipsoidSoftBody;


            }

            function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

				var threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
				var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
				shape.setMargin( margin );

				createRigidBody( threeObject, shape, mass, pos, quat );

				return threeObject;

            }

            function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

            	threeObject.position.copy( pos );
            	threeObject.quaternion.copy( quat );

				var transform = new Ammo.btTransform();
    			transform.setIdentity();
    			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
    			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
				var motionState = new Ammo.btDefaultMotionState( transform );

				var localInertia = new Ammo.btVector3( 0, 0, 0 );
		    	physicsShape.calculateLocalInertia( mass, localInertia );

		    	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
		    	var body = new Ammo.btRigidBody( rbInfo );

				threeObject.userData.physicsBody = body;

				scene.add( threeObject );

				if ( mass > 0 ) {
					rigidBodies.push( threeObject );

					// Disable deactivation
					body.setActivationState( 4 );
				}

				physicsWorld.addRigidBody( body );

            }

			function createRandomColor() {
				return Math.floor( Math.random() * ( 1 << 24 ) );
			}

            function createMaterial() {
            	return new THREE.MeshPhongMaterial( { color: createRandomColor() } );
            }

            function initInput() {

            	window.addEventListener( 'keydown', function( event ) {

					switch ( event.keyCode ) {
						// Q
						case 81:
							armMovement = 1;
						break;

						// A
						case 65:
							armMovement = - 1;
						break;
					}

            	}, false );

				window.addEventListener( 'keyup', function( event ) {

					armMovement = 0;

            	}, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                render();
                stats.update();

            }

            function render() {

            	var deltaTime = clock.getDelta();

            	updatePhysics( deltaTime );

                controls.update( deltaTime );

                renderer.render( scene, camera );

                time += deltaTime;

            }

            function updatePhysics( deltaTime ) {

            	// Hinge control
            	//hinge.enableAngularMotor( true, 1.5 * armMovement, 50 );

				// Step world
				physicsWorld.stepSimulation( deltaTime, 10 );

                // update ellipsoid

                var softBody = ellipsoid.userData.physicsBody;
                var pos = ellipsoid.geometry.attributes.position.array;
                var order = ellipsoid.geometry.attributes.order.array;
                var numVerts = pos.length / 3;
                var nodes = softBody.get_m_nodes();
                var indexFloat = 0, n;
                for ( var i = 0; i < numVerts; i ++ ) {
                    n = order[i] * 3;
                    var node = nodes.at( i );
                    var nodePos = node.get_m_x();
                    pos[ n ] = nodePos.x();
                    pos[ n+1 ] = nodePos.y();
                    pos[ n+2 ] = nodePos.z();
                }

                ellipsoid.geometry.attributes.position.needsUpdate = true;
                ellipsoid.geometry.computeVertexNormals();
                ellipsoid.geometry.computeBoundingSphere();


			    // Update rigid bodies
			    for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
			    	var objThree = rigidBodies[ i ];
			    	var objPhys = objThree.userData.physicsBody;
					var ms = objPhys.getMotionState();
					if ( ms ) {

			        	ms.getWorldTransform( transformAux1 );
						var p = transformAux1.getOrigin();
						var q = transformAux1.getRotation();
						objThree.position.set( p.x(), p.y(), p.z() );
						objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

			      	}
			    }

			}

        </script>

    </body>
</html>
